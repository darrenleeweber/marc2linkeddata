#!/usr/bin/env ruby

require 'marc2linkeddata'

CONFIG = Marc2LinkedData.configuration

def stack_trace(e, record)
  $stderr.write "\n"
  $stderr.write "ERROR\n"
  $stderr.write e.message
  $stderr.write e.backtrace
  $stderr.write "\n"
  $stderr.write record.to_s
  $stderr.write "\n"
end

def marc_record2turtle(auth, output_path=nil)
  begin
    # ParseMarcAuthority is a lazy parser, so
    # init only assigns record to an instance var.
    triples = auth.to_ttl.lines
    binding.pry if (CONFIG.debug && triples.empty?)
    triples.delete_if {|l| l.chomp.empty? }
    # Output the triples to a turtle file.
    ld_filename = File.join(output_path, "auth_#{auth.get_id}.ttl")
    CONFIG.logger.info "Writing triples in turtle to #{ld_filename}"
    ld_file = File.open(ld_filename,'w')
    ld_file.write(triples.join)
    ld_file.flush
    ld_file.close
  rescue => e
    stack_trace(e, auth.record)
    binding.pry if CONFIG.debug
  end
end



# ---------------------------------------------------------------------
# MAIN


marc_files = []
ARGV.each do |filename|
  path = Pathname(filename)
  marc_files.push(path) if path.exist?
end
if marc_files.empty?
  script_name = File.basename(__FILE__)
  script_path = File.dirname(__FILE__)
  example_env_file = File.absolute_path(File.join(script_path,'..','.env_example'))
  puts <<HELP
#{script_name} marc_authority_file1.mrc [ marc_authority_file2.mrc .. marc_authority_fileN.mrc ]

Output is RDF triples in turtle files (.ttl). The files are output into a
directory created in the same path as the .mrc file,
with one .ttl file for each record.

Optional configuration can be set in environment variables. A '.env' file can be
created in the path where this utility is run and this utility will use it. See
comments and settings in the example file at:
#{example_env_file}

HELP
  exit!
end

puts "Logging to: #{CONFIG.log_file}"
marc_files.each do |path|
  CONFIG.logger.info "Processing: #{path}"
  # marc_file2ld(path.to_s)
  output_dir = path.basename.to_s.gsub('.mrc','').gsub('.','_') + '_turtle'
  output_path = File.join(path.dirname.to_s, output_dir)
  Dir.mkdir(output_path, 0775) unless File.directory? output_path
  auth_records = Marc2LinkedData::Utils.marc_authority_records(path.to_s)
  if CONFIG.threads
    # Allow Parallel to automatically determine the optimal concurrency model.
    # Note that :in_threads crashed and :in_processes worked.
    # Parallel.each(auth_records, :progress => 'Records: ', :in_threads=>CONFIG.thread_limit) do |r|
    # Parallel.each(auth_records, :progress => 'Records: ', :in_processes=>CONFIG.thread_limit) do |r|
    Parallel.each(auth_records, :progress => 'Records: ') do |auth|
      marc_record2turtle(auth, output_path)
    end
  else
    progress = ProgressBar.create(:total => auth_records.length, :format => '%a %f |%b>>%i| %P%% %t')
    auth_records.each do |auth|
      marc_record2turtle(auth, output_path)
      progress.increment
    end
  end
end


